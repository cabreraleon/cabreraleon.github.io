---
layout: post
title: Module 2 - PRMs
---

I read a revolutionary robotics journal paper titled Probabilistic Roadmaps for Path Planning in High-Dimensional Configuration Spaces by Kavraki et al (1996). The Probabilistic Roadmap (PRM) algorithm was designed to solve robot motion planning problems for holonomic robots in static workspaces. The PRM consists of the learning phase — where the roadmap construction and expansion steps occur — and the query phase. This paper concluded the PRM can be applied to virtually any type of holonomic robot and can be easily customized to run more efficiently on a large array of problems. <br><br>

The experiments in Kavraki et al (1996) tested their customized PRM method as well as general path planning methods like the Randomized Path Planner (RPP). All experiments are 2-dimensional. The parameters included two scenes. Each scene contains polygonal obstacles and a planar articulated robot whose linkages are line segments, which does not limit the methods used. The first scene has a 4-dof robot with three resolute joints and one prismatic joint. The second scene has a 5-resolute joint robot and narrow areas in the workspace. <br><br>

The experiments customized the PRM method to planar articulated robots and experiments with both a general and a customized implementation of the PRM. The customized implementation was able to solve very difficult path planning queries involving many-dof robots in a fraction of a seconds after a learning time of a couple dozen seconds. The general implementation was much slower and was able to solve the same problems in several minutes but it was still relatively efficient in less difficult problems. The results showed that the general implementation is able to efficiently solve complex planning problems, but when applied to problems involving more DOFs, the learning times required to build an adequate roadmap is significantly longer (e.g. about 25 minutes for one of their tests). <br><br>

The results conclusively proved that their PRM method can efficiently solve problems for planar articulated robots with many DOFs much more consistent than the RPP.  Although the RPP can be very fast on some difficult problems, it may take restricting time on some others. Such a disparity was not observed in the PRM, since it  answered queries considerably faster than RRP, usually in a matter of a few dozen seconds. The paper ended with open ended questions such as how the PRM could be applied to more complex two or three dimensional geometries, since the cost of collision checking would be much higher. Another question was how to extend the PRM method to dynamic schemes, where objects can be removed or added and environments are subject to incremental changes, which was a major motion planning problem in the mid-1990s. <br><br>

## PRM Algorithm 
 The Probabilistic Roadmap (PRM) algorithm is critical to motion planning because it builds a practical, well-connected graph for a robot to travel through a path in the C-free space of a C-space. The PRM method has two phases: a learning phase and a query phase. <br><br>

 ![module1assignment](https://cabreraleon.github.io/images/fig29.png)
 Figure 29. Main Steps of the PRM (Source: http://motion.cs.illinois.edu/RoboticSystems/MotionPlanningHigherDimensions.html/) 

 <br>

 The learning phase has two steps: the construction step and the expansion step. The first step constructs and stores a probabilistic roadmap as an undirected graph R(N, E) where the nodes in N represent collision-free configurations in the C-space and the edges in E correspond to feasible paths between these configurations. My explanation of the PRM algorithm follows.

 ![module1assignment](https://cabreraleon.github.io/images/fig30.png) <br>
    **Figure 30. PRM Algorithm Pseudocode (Kavraki, 1996)** <br><br>

In the **construction step**, the graph R=(N,E) is initially empty,
1. node set N is empty and 
2. edge set E is empty. Then, 
3. in a loop,
4. a random free configuration c is generated and 
5. we select a number of nodes Nc of candidate neighbors from the current node set N and try to connect random free node c to the selected Nc nodes using the local planner. 
6. add the random configuration c to node set N. For each new random free node c, 
7. For all n nodes in Nc chosen in order of increasing distance from c, the local planner tries to see if the pair of components c and n are connected. 
8. If the local planner succeeds in computing a feasible patch between c and the selected node n, 
9. then the edge(c, n) is added to edge set E. 
10. Finally, (10) graph R's connected components are dynamically updated with the newest values of node set N and edge set E. 

The **expansion step** improves the connectivity of the graph R generated by the construction step. Here, the graph is based on the difficult regions that the nodes might be in. When expanding configuration c, the procedure selects a new free configuration in the neighborhood of c, adds this configuration to N, and tries to connect it to other nodes of N in the same way that it was done in the construction step. This expansion increases the density of roadmap configurations in the difficult C-free regions. <br><br>

In the **query phase**, the PRM chooses a random start configuration s and goal configuration g in the C-free space and adds/connects them to the roadmap created in the learning phase. Then, the PRM checks if it can find an edge between them. Also in this phase, a path is found in the roadmap between connected nodes.<br><br>

## Time Complexity 
<br>
For the roadmap construction of n samples, it takes O(n) time to sample but O(n2) time for local planner attempts in the worst case. It takes O(n) time to add a start or end goal node to the roadmap. The time to add start and end nodes gets added to the query complexity, O(n2 + n log n) + O(n) + O(n)  but then we drop the  lower order terms. The complexity of querying the roadmap is O(n2 + n log n). The worst case, in fully connected graphs, is O(n2). 
